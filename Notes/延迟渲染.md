(参考[延迟渲染 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/102134614))

- 为什么需要延迟渲染
	前向渲染对很多看不到的光源进行光照着色
	前向渲染枚举每一个片元，在对所有光照信息进行累加光照计算，时间复杂度为O(nm),代价大

延迟渲染先渲染场景一次获取对象的各种几何信息，并储存在G缓冲中(MRT),各种信息保存在对应贴图信息中。
![](https://learnopengl-cn.github.io/img/05/08/deferred_overview.png)
从第一次pass获取了屏幕空间下的光照信息，在第二次pass中对已经经过深度测试后屏幕空间下的片元进行光照计算。
缺陷:
- 延迟渲染基于后处理，自然不能使用基于硬件的AA抗锯齿(MSAA等)，UE4启用延迟渲染后只支持FXAA跟TXAA。
- 不支持透明物体的渲染：渲染透明物体的逻辑是对每个图元做深度测试，mix混合，但是渲染到texture只能记录一个像素。妥协方案是先渲染非透明的Mesh，后续再单独渲染透明Mesh。
- 带宽占用大：在1920 * 1080 * 4（RGBA）* 4（MRT）* 8（Byte to bit） * 60（FPS），占用的带宽15G。
- 只能使用同一个光照pass：使用屏幕空间下的结果进行渲染，自然不能得到像素归属哪一个mesh，使用哪一个shader。

| 前向渲染     | 延迟渲染        |
| -------- | ----------- |
| 使用片段相关信息 | 使用Gbuffer数据 |
| O(nm)    | O(n+m)      |
| 光照计算每个像素 | 计算看得见的像素    |
